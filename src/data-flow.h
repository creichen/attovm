/***************************************************************************
  Copyright (C) 2014 Christoph Reichenbach


 This program may be modified and copied freely according to the terms of
 the GNU general public license (GPL), as long as the above copyright
 notice and the licensing information contained herein are preserved.

 Please refer to www.gnu.org for licensing details.

 This work is provided AS IS, without warranty of any kind, expressed or
 implied, including but not limited to the warranties of merchantability,
 noninfringement, and fitness for a specific purpose. The author will not
 be held liable for any damage caused by this work or derivatives of it.

 By using this source code, you agree to the licensing terms as stated
 above.


 Please contact the maintainer for bug reports or inquiries.

 Current Maintainer:

    Christoph Reichenbach (CR) <creichen@gmail.com>

***************************************************************************/

#ifndef _ATTOL_DATA_FLOW_H
#define _ATTOL_DATA_FLOW_H

#include <stdbool.h>

#include "control-flow-graph.h"
#include "symbol-table.h"
#include "ast.h"

/*e
 * Reports an error at a given AST node
 *
 * @param node The node to report the error for
 * @param fmt A format string (as for printf)
 * @param ... Any additional parameters needed for the format string (cf. `man printf')
 */
static void
data_flow_error(const ast_node_t *node, char *fmt, ...);

struct data_flow_postprocessor;

//e data flow analysis definitions

typedef struct data_flow_analysis {
	//e forward analysis?  otherwise backward
	bool forward;
	//e name of the analysis
	char *name;

	
	int unique_global_index;	/*e internal: unique global index for analysis (assigned automatically) */
	bool debug;			/*e internal: should we debug execution of this? */

	/*e initialise set of data flow facts for given AST node
	 *
	 * @param sym Symbol table entry of the function/constructor/method we are operating within
	 * @param node AST node to initialise for
	 * @return A void * with the initial output
	 */
	void * (*init)(symtab_entry_t *sym, ast_node_t *node);

	/*e
	 * Print out the given data flow fact, for debugging/pretty-printing
	 *
	 * @param file The output stream to print to
	 * @param sym Symbol table entry of the function/constructor/method we are operating within
	 * @param data The fact to print
	 */
	void (*print)(FILE *file, symtab_entry_t *sym, void *data);

	/*e
	 * Joins two data flow facts
	 *
	 * @param sym Symbol table entry of the function/constructor/method we are operating within
	 * @param in1, in2 The data flow fact to join
	 * @return The joined data flow fact
	 */
	void * (*join)(symtab_entry_t *sym, void *in1, void *in2);

	/*e
	 * Computes the effects of the transfer function for the given data flow node
	 *
	 * @param sym Symbol table entry of the function/constructor/method we are operating within
	 * @param ast The AST node generating the transfer function
	 * @return The data flow fact generated by transferring `in' through `ast'
	 */
	void * (*transfer)(symtab_entry_t *sym, ast_node_t *ast, void *in);

	/*e
	 * Compares two data flow facts
	 *
	 * @param sym Symbol table entry of the function/constructor/method we are operating within
	 * @param lhs, rhs Left-hand side and right-hand side of the comparison
	 * @return True iff lhs carries less than or the same information as the right-hand side
	 */
	bool (*is_less_than_or_equal)(symtab_entry_t *sym, void *lhs, void *rhs);

	/*e
	 * Duplicates a flow fact
	 *
	 * @param sym Symbol table entry of the function/constructor/method we are operating within
	 * @param fact The fact to duplicate
	 */
	void *(*copy)(symtab_entry_t *sym, void *fact);

	/*e
	 * Deallocates a data flow fact
	 *
	 * @param fact The fact to deallocate
	 */
	void (*free)(void *fact);

	//e optional (may be NULL) post-processing to exploit inferred data flow facts
	struct data_flow_postprocessor *postprocessor;
} data_flow_analysis_t;

typedef struct data_flow_postprocessor {
	/*e
	 * Initialises the data flow postprocessor
	 *
	 * (optional, may be NULL)
	 *
	 * @param sym Symbol that we analysed
	 * @param context Pointer to optional storage that the postprocessor can use to carry context
	 */
	void (*init)(symtab_entry_t *sym, void **context);

	/*e
	 * Visits individual AST node
	 *
	 * (optional, may be NULL)
	 *
	 * @param sym Symbol that we analysed
	 * @param context Pointer to storage initialised by `init', where appropriate
	 * @param node Node to analyse (guaranteed to have node->cfg)
	 */
	void (*visit_node)(symtab_entry_t *sym, void *context, ast_node_t *node);
} data_flow_postprocessor_t;


/*e
 * Frees an array of data flow analysis results (from a CFG node)
 */
void
data_flow_free(cfg_data_flow_facts_t *data);

/*e
 * Prints out analysis results for the specified cfg node
 *
 * @param file File to print to
 * @param node CFG node containing the analysis results we want to print
 * @param flags Bit-flags to indicate which analysis results to print, with the least
 * significant bit printing analysis #0, the next bit enabling printing analysis #1 etc.
 */
void
data_flow_print(FILE *file, cfg_node_t *node, int flags);


/*e
 * Returns data flow analysis by its given index
 *
 * Valid indices are in [0 .. DATA_FLOW_ANALYSES_NR - 1]
 *
 * @param index The index to look up
 * @return The matching data flow analysis, or NULL if none matches
 */
data_flow_analysis_t *
data_flow_analysis_by_index(int index);


/*e
 * Returns data flow analysis by name
 *
 * @param name The name to look up
 * @return The matching data flow analysis, or NULL if none matches
 */
data_flow_analysis_t *
data_flow_analysis_by_name(char *name);

#endif // !defined(_ATTOL_DATA_FLOW_H)
